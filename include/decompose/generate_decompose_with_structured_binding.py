#!/usr/bin/env python3
max_n = 50

import datetime
import pathlib
dir = pathlib.Path(__file__).parent
script_name = "include/decompose/" + pathlib.Path(__file__).name

def generate(n):
    var_list = ", ".join(f"_{i}" for i in range(n))
    fwd_list = ", ".join(f"std::forward<decltype(_{i})>(_{i})" for i in range(n))
    # return "if constexpr(requires{ ({auto&& [" + var_list + "] = std::forward<T>(t);}); }) {\n" + \
    #     "        auto&& [" + var_list + "] = std::forward<T>(t);\n" + \
    #     "        return std::forward<F>(f)(" + fwd_list + ");\n" + \
    #     "    } else "
    return f"    auto c{n} = " + "[](auto&& t) -> decltype(({\n" + \
            f"                auto&& [{var_list}] = std::forward<decltype(t)>(t);\n" + \
            f"                std::integral_constant<int, {n}>();\n" + \
            "            })) {\n" + \
            "        return {};\n" + \
            "    };\n" + \
            f"    auto f{n} = [](std::integral_constant<int, {n}>, auto&& t, auto&& f) -> decltype(auto) " + "{\n" + \
            f"        auto&& [{var_list}] = std::forward<decltype(t)>(t);\n" + \
            f"        return std::forward<decltype(f)>(f)({fwd_list});\n" + \
            "    };\n"


source = f"// This file is automatically generated by {script_name}.\n" + \
         f"// DateTime: {datetime.datetime.now()}\n" + \
'''
#pragma once

#include <utility>
#include <type_traits>
namespace decompose::detail{

template <class... Ts>
struct overload_t : Ts... {
    overload_t(const Ts&... ts) : Ts(std::move(ts))... {}
    using Ts::operator()...;
};

struct any{
    template<class T>
    any(T&& t) {}
};
}
namespace decompose{
/** @brief Decompose a struct/array/tuple with structured binding and call `f` with the decomposed elements.
  * @param t The struct/array/tuple to decompose.
  * @param f The function to call with the decomposed elements.
  * @return The return value of `f`.
*/
template<class T, class F>
constexpr decltype(auto) decompose_with_structured_binding(T&& t, F&& f){
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wempty-decomposition"

    auto c_error = [&]<class = void>(detail::any&&){
        static_assert([]{return false;}(), 
            "T could not be decomposed by structured binding. "
            "Possible causes: "
            "1. T has a private/protected field. "
            "2. T's fields come from different base classes. "
            "3. T has a field of an anonymous union type. "
            "4. T has more than `max_n`(= ''' + str(max_n) + ''') fields. "
            "In the last case, you can increase the size of `max_n` in " 
            "''' + script_name + ''' and regenerate the code.\\n");
    };
''' + \
    "".join(generate(n) for n in range(0, max_n+1)) + "\n" + \
    "    auto cnt = detail::overload_t{" + ", ".join([f"c{i}" for i in range(max_n+1)]) + ", c_error}(std::forward<T>(t));\n" + \
    "    return detail::overload_t{" + ", ".join([f"f{i}" for i in range(max_n+1)]) + "}(cnt, std::forward<T>(t), std::forward<F>(f));\n" + \
'''
    #pragma clang diagnostic pop
}

} // namespace decompose
'''

open(dir / "decompose_with_structured_binding.hpp", "w").write(source)
