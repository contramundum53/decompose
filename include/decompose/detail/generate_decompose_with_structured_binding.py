#!/usr/bin/env python3
max_n = 50

import datetime
import pathlib
dir = pathlib.Path(__file__).parent
script_name = "include/decompose/detail/" + pathlib.Path(__file__).name

def generate_c(n):
    var_list = ", ".join(f"_{i}" for i in range(n))
    return f"    constexpr auto c{n} = " + "[](auto&& t) -> decltype(({\n" + \
           f"                auto&& [{var_list}] = std::forward<decltype(t)>(t);\n" + \
           f"                std::integral_constant<int, {n}>();\n" + \
            "            })) {\n" + \
            "        return {};\n" + \
            "    };\n"
def generate_f(n):
    var_list = ", ".join(f"_{i}" for i in range(n))
    fwd_list = ", ".join(f"std::forward<decltype(_{i})>(_{i})" for i in range(n))
    return f"        constexpr auto f{n} = [](std::integral_constant<int, {n}>, auto&& t, auto&& f) -> decltype(auto) " + "{\n" + \
           f"            auto&& [{var_list}] = std::forward<decltype(t)>(t);\n" + \
           f"            return std::forward<decltype(f)>(f)({fwd_list});\n" + \
           "        };\n"


source = f"// This file is automatically generated by {script_name}.\n" + \
         f"// DateTime: {datetime.datetime.now()}\n" + \
'''
#pragma once

#include "util.hpp"

namespace decompose::detail{
template<class T>
constexpr int structured_binding_num = []{
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wempty-decomposition"
''' + \
    "".join(generate_c(n) for n in range(0, max_n+1)) + "\n" + \
'''
    constexpr auto c_error = [](detail::any&&) -> std::integral_constant<int, -1> {
        return {};
    };
''' + \
"    constexpr auto cnt_func = detail::overload_t{" + ", ".join([f"c{i}" for i in range(max_n+1)]) + ", c_error};\n" + \
'''    
    using cnt_t = decltype(cnt_func(std::declval<T>()));
    return cnt_t::value;
    #pragma clang diagnostic pop
}();

template<class T>
concept decomposable_with_structured_binding = (structured_binding_num<T> >= 0);

/** @brief Decompose a struct/array/tuple with structured binding and call `f` with the decomposed elements.
  * @param t The struct/array/tuple to decompose.
  * @param f The function to call with the decomposed elements.
  * @return The return value of `f`.
*/
template<class T, class F>
constexpr decltype(auto) decompose_with_structured_binding(T&& t, F&& f){

    constexpr int sb_num = structured_binding_num<T>;
    if constexpr(sb_num == -1){
        static_assert([]<class = void>{return false;}(), 
            "T could not be decomposed by structured binding. "
            "Possible causes: "
            "1. T has a private/protected field. "
            "2. T's fields come from different base classes. "
            "3. T has a field of an anonymous union type. "
            "4. T has more than `max_n`(= ''' + str(max_n) + ''') fields. "
            "In the last case, you can increase the size of `max_n` in " 
            "''' + script_name + ''' and regenerate the code.\\n");
    } else{

        #pragma clang diagnostic push
        #pragma clang diagnostic ignored "-Wempty-decomposition"
''' + \
"".join(generate_f(n) for n in range(0, max_n+1)) + "\n" + \
"        return detail::overload_t{" + ", ".join([f"f{i}" for i in range(max_n+1)]) + "}(std::integral_constant<int, sb_num>{}, std::forward<T>(t), std::forward<F>(f));\n" + \
'''
    }
        #pragma clang diagnostic pop
}


} // namespace decompose::detail
'''

open(dir / "decompose_with_structured_binding.hpp", "w").write(source)
